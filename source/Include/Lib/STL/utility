#pragma once
#include <Lib/Types/Uefi.hpp>
#include <Lib/STL/type_traits>
PUBLIC namespace QuantumNEC::Lib::STL {
    /**
     * @brief Convert a value to an rvalue.
     * @param __t A thing of arbitaray type.
     * @return The parameter cast to an rvalue-reference to allow moving it.
     */
    PUBLIC template < typename _Tp >
    constexpr typename remove_reference< _Tp >::type &&move( IN _Tp && __t ) {
        return static_cast< typename remove_reference< _Tp >::type && >( __t );
    }
    PUBLIC template < class T >
    constexpr T &&forward( remove_reference_t< T > & arg ) noexcept {
        // forward an lvalue as either an lvalue or an rvalue
        return ( static_cast< T && >( arg ) );
    }

    PUBLIC template < class T >
    constexpr T &&forward( remove_reference_t< T > && arg ) noexcept {
        // forward an rvalue as an rvalue
        return ( static_cast< T && >( arg ) );
    }
    PUBLIC template < typename _Tp, _Tp... _Idx >
    struct integer_sequence
    {
        using value_type = _Tp;
        static constexpr Lib::Types::size_t size( ) noexcept {
            return sizeof...( _Idx );
        }
    };
    PUBLIC template < Lib::Types::size_t... _Idx >
    using index_sequence = integer_sequence< Lib::Types::size_t, _Idx... >;
    template < typename _Tp, _Tp _Num >
    using make_integer_sequence
#if __has_builtin( __make_integer_seq )
        = __make_integer_seq< integer_sequence, _Tp, _Num >;
#else
        = integer_sequence< _Tp, __integer_pack( _Num )... >;
#endif
    /// Alias template make_index_sequence
    template < Lib::Types::size_t _Num >
    using make_index_sequence = make_integer_sequence< Lib::Types::size_t, _Num >;

    /// Alias template index_sequence_for
    template < typename... _Types >
    using index_sequence_for = make_index_sequence< sizeof...( _Types ) >;
}