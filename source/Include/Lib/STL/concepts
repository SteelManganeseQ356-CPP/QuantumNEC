#pragma once
#include <Lib/STL/type_traits>
#include <Lib/STL/utility>
PUBLIC namespace QuantumNEC::Lib::STL {
    PUBLIC namespace detail {
        template < class T, class U >
        concept SameHelper = is_same_v< T, U >;
    }
    PUBLIC template < class T, class U >
    concept same_as = detail::SameHelper< T, U > && detail::SameHelper< U, T >;
    PUBLIC template < class Derived, class Base >
    concept derived_from =
        is_base_of_v< Base, Derived > && is_convertible_v< const volatile Derived *, const volatile Base * >;
    PUBLIC template < class From, class To >
    concept convertible_to =
        is_convertible_v< From, To > && requires {
            static_cast< To >( declval< From >( ) );
        };
    PUBLIC template < class T >
    concept integral = is_integral_v< T >;
    PUBLIC template < class T >
    concept signed_integral = integral< T > && is_signed_v< T >;
    PUBLIC template < class T >
    concept unsigned_integral = integral< T > && !is_signed_v< T >;
    PUBLIC template < class T >
    concept floating_point = is_floating_point_v< T >;
    PUBLIC template < class T, class U >
    concept common_reference_with =
        same_as< common_reference_t< T, U >, common_reference_t< U, T > > && convertible_to< T, common_reference_t< T, U > > && convertible_to< U, common_reference_t< T, U > >;

    PUBLIC template < class LHS, class RHS >
    concept assignable_from =
        is_lvalue_reference_v< LHS > && common_reference_with< const remove_reference_t< LHS > &, const remove_reference_t< RHS > & > && requires( LHS lhs, RHS &&rhs ) {
            { lhs = forward< RHS >( rhs ) } -> same_as< LHS >;
        };
    PUBLIC template < typename _Tp >
    concept destructible = detail::__destructible< _Tp >;
    /// [concept.constructible], concept constructible_from
    PUBLIC template < typename _Tp, typename... _Args >
    concept constructible_from = destructible< _Tp > && is_constructible_v< _Tp, _Args... >;

    /// [concept.defaultinitializable], concept default_initializable
    PUBLIC template < typename _Tp >
    concept default_initializable = constructible_from< _Tp >
                                    && requires {
                                           _Tp { };
                                           (void)::new _Tp;
                                       };
    /// [concept.moveconstructible], concept move_constructible
    PUBLIC template < typename _Tp >
    concept move_constructible = constructible_from< _Tp, _Tp > && convertible_to< _Tp, _Tp >;

    /// [concept.copyconstructible], concept copy_constructible
    PUBLIC template < typename _Tp >
    concept copy_constructible = move_constructible< _Tp >
                                 && constructible_from< _Tp, _Tp & > && convertible_to< _Tp &, _Tp >
                                 && constructible_from< _Tp, const _Tp & > && convertible_to< const _Tp &, _Tp >
                                 && constructible_from< _Tp, const _Tp > && convertible_to< const _Tp, _Tp >;
}
