#pragma once
#include <Lib/Types/Uefi.hpp>
#include <Lib/Types/type_bool.hpp>

PUBLIC namespace QuantumNEC::Lib::STL {
    template < typename _Tx, typename _Ty >
    struct is_same
    {
        STATIC constexpr Lib::Types::BOOL value { FALSE };
    };
    template < typename _T >
    struct is_same< _T, _T >
    {
        STATIC constexpr Lib::Types::BOOL value { TRUE };
    };
    template < typename _Tx, typename _Ty >
    constexpr Lib::Types::BOOL is_same_v { is_same< _Tx, _Ty >::value };

    template < class T, T v >
    struct integral_constant
    {
        static constexpr T value = v;
        using value_type = T;
        using type = integral_constant;     // using injected-class-name
        constexpr operator value_type( ) const noexcept {
            return value;
        }
        constexpr value_type operator( )( ) const noexcept {
            return value;
        }     // since c++14
    };
    using true_type = integral_constant< bool, true >;
    using false_type = integral_constant< bool, false >;

    template < class T >
    struct is_union
    {
        STATIC CONST Lib::Types::BOOL value = __is_union( T );
    };

    namespace detail {
    template < class T >
    integral_constant< bool, !is_union< T >::value > test( int T::* );

    template < class >
    false_type test( ... );
    }     // namespace detail

    template < class T >
    struct is_class : decltype( detail::test< T >( nullptr ) )
    {};
    namespace detail {
    template < class T >
    struct type_identity
    {
        using type = T;
    };     // or use std::type_identity (since C++20)

    template < class T >     // Note that `cv void&` is a substitution failure
    auto try_add_lvalue_reference( int ) -> type_identity< T & >;
    template < class T >     // Handle T = cv void case
    auto try_add_lvalue_reference( ... ) -> type_identity< T >;

    template < class T >
    auto try_add_rvalue_reference( int ) -> type_identity< T && >;
    template < class T >
    auto try_add_rvalue_reference( ... ) -> type_identity< T >;
    }     // namespace detail
    template < bool B, class T, class F >
    struct conditional
    {
        using type = T;
    };

    template < class T, class F >
    struct conditional< false, T, F >
    {
        using type = F;
    };
    template < bool B, class T, class F >
    using conditional_t = typename conditional< B, T, F >::type;
    template < class... >
    struct conjunction : true_type
    {};
    template < class B1 >
    struct conjunction< B1 > : B1
    {};
    template < class B1, class... Bn >
    struct conjunction< B1, Bn... > : conditional_t< bool( B1::value ), conjunction< Bn... >, B1 >
    {};
    template < class... B >
    inline constexpr bool conjunction_v = conjunction< B... >::value;
    template < class T >
    struct add_lvalue_reference : decltype( detail::try_add_lvalue_reference< T >( 0 ) )
    {};

    template < class T >
    struct add_rvalue_reference : decltype( detail::try_add_rvalue_reference< T >( 0 ) )
    {};
    template < typename T >
    constexpr bool always_false = false;

    template < typename T >
    typename add_rvalue_reference< T >::type declval( ) noexcept {
        static_assert( always_false< T >, "declval not allowed in an evaluated context" );
    }
    PUBLIC namespace detail {
        template < class T >
        auto test_returnable( int )->decltype( void( static_cast< T ( * )( ) >( nullptr ) ), true_type { } );
        template < class >
        auto test_returnable( ... )->false_type;

        template < class From, class To >
        auto test_implicitly_convertible( int )->decltype( void( declval< void ( & )( To ) >( )( declval< From >( ) ) ), true_type { } );
        template < class, class >
        auto test_implicitly_convertible( ... )->false_type;
    }     // namespace detail
    template < class From, class To >
    auto test_implicitly_convertible( int )->decltype( void( declval< void ( & )( To ) >( )( declval< From >( ) ) ), true_type { } );
    template < class, class >
    auto test_implicitly_convertible( ... )->false_type;

    template < class T >
    struct is_void : is_same< void, T >
    {};
    PUBLIC namespace details {
        template < typename B >
        true_type test_ptr_conv( const volatile B * );
        template < typename >
        false_type test_ptr_conv( const volatile void * );

        template < typename B, typename D >
        auto test_is_base_of( int )->decltype( test_ptr_conv< B >( static_cast< D * >( nullptr ) ) );
        template < typename, typename >
        auto test_is_base_of( ... )->true_type;     // private or ambiguous base
    }                                               // namespace details

    template < typename Base, typename Derived >
    struct is_base_of :
        integral_constant<
            bool,
            is_class< Base >::value && is_class< Derived >::value &&decltype( details::test_is_base_of< Base, Derived >( 0 ) )::value >
    {};
    PUBLIC namespace detail {
        template < class T >
        auto test_returnable( int )->decltype( void( static_cast< T ( * )( ) >( nullptr ) ), true_type { } );
        template < class >
        auto test_returnable( ... )->false_type;

        template < class From, class To >
        auto test_implicitly_convertible( int )->decltype( void( declval< void ( & )( To ) >( )( declval< From >( ) ) ), true_type { } );
        template < class, class >
        auto test_implicitly_convertible( ... )->false_type;
    }     // namespace detail

    template < class From, class To >
    struct is_convertible : integral_constant< bool, ( decltype( detail::test_returnable< To >( 0 ) )::value && decltype( detail::test_implicitly_convertible< From, To >( 0 ) )::value ) || ( is_void< From >::value && is_void< To >::value ) >
    {};
    template < class From, class To >
    struct is_nothrow_convertible : conjunction< is_void< From >, is_void< To > >
    {};

    template < class From, class To >
        requires requires {
            static_cast< To ( * )( ) >( nullptr );
            { declval< void ( & )( To ) noexcept >( )( declval< From >( ) ) } noexcept;
        }
    struct is_nothrow_convertible< From, To > : true_type
    {};
    template < class Base, class Derived >
    inline constexpr bool is_base_of_v = is_base_of< Base, Derived >::value;
    template < class From, class To >
    inline constexpr bool is_convertible_v = is_convertible< From, To >::value;
    template < class From, class To >
    inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible< From, To >::value;
    template < bool B >
    using bool_constant = integral_constant< bool, B >;
    // Note: this implementation uses C++20 facilities
    template < class T >
        struct is_integral : bool_constant < requires( T t, T * p, void ( *f )( T ) )     // T* parameter excludes reference types
    {
        reinterpret_cast< T >( t );     // Exclude class types
        f( 0 );                         // Exclude enumeration types
        p + t;                          // Exclude everything not yet excluded but integral types
    } > { };
    template < class T >
    inline constexpr bool is_integral_v = is_integral< T >::value;
    template < class T >
    struct remove_cv
    {
        typedef T type;
    };
    template < class T >
    struct remove_cv< const T >
    {
        typedef T type;
    };
    template < class T >
    struct remove_cv< volatile T >
    {
        typedef T type;
    };
    template < class T >
    struct remove_cv< const volatile T >
    {
        typedef T type;
    };

    template < class T >
    struct remove_const
    {
        typedef T type;
    };
    template < class T >
    struct remove_const< const T >
    {
        typedef T type;
    };

    template < class T >
    struct remove_volatile
    {
        typedef T type;
    };
    template < class T >
    struct remove_volatile< volatile T >
    {
        typedef T type;
    };
    template < class T >
    using remove_cv_t = typename remove_cv< T >::type;
    template < class T >
    using remove_const_t = typename remove_const< T >::type;
    template < class T >
    using remove_volatile_t = typename remove_volatile< T >::type;
    template < class T >
    struct is_floating_point :
        integral_constant< bool, is_same< float, typename remove_cv< T >::type >::value || is_same< double, typename remove_cv< T >::type >::value || is_same< long double, typename remove_cv< T >::type >::value >
    {};
    template < class T >
    inline constexpr bool is_floating_point_v = is_floating_point< T >::value;
    template < class T >
    struct is_arithmetic : integral_constant< bool, is_integral< T >::value || is_floating_point< T >::value >
    {};
    PUBLIC namespace detail {
        template < typename T, bool = is_arithmetic< T >::value >
        struct is_signed : integral_constant< bool, T( -1 ) < T( 0 ) >
        {};

        template < typename T >
        struct is_signed< T, false > : false_type
        {};
    }

    template < typename T >
    struct is_signed : detail::is_signed< T >::type
    {};
    template < class T >
    inline constexpr bool is_signed_v = is_signed< T >::value;
    template < class T >
    struct is_lvalue_reference : false_type
    {};
    template < class T >
    struct is_lvalue_reference< T & > : true_type
    {};

    template < class T >
    inline constexpr bool is_lvalue_reference_v = is_lvalue_reference< T >::value;

    template < class _Tp >
    struct remove_reference
    {
        using type = _Tp;
    };
    template < class _Tp >
    struct remove_reference< _Tp & >
    {
        using type = _Tp;
    };
    template < class _Tp >
    struct remove_reference< _Tp && >
    {
        using type = _Tp;
    };
    template < class _Tp >
    using remove_reference_t = typename remove_reference< _Tp >::type;

    template < typename... _Tp >
    struct common_reference;

    template < typename... _Tp >
    using common_reference_t = typename common_reference< _Tp... >::type;

    template < typename... _Tp >
    struct common_type;
    // If sizeof...(T) is zero, there shall be no member type.
    template <>
    struct common_type<>
    {};

    // If sizeof...(T) is one, the same type, if any, as common_type_t<T0, T0>.
    template < typename _Tp0 >
    struct common_type< _Tp0 > : public common_type< _Tp0, _Tp0 >
    {};

    // If sizeof...(T) is zero, there shall be no member type.
    template <>
    struct common_reference<>
    {};

    // If sizeof...(T) is one ...
    template < typename _Tp0 >
    struct common_reference< _Tp0 >
    {
        using type = _Tp0;
    };
    template < typename _Tp >
    inline constexpr bool is_enum_v = __is_enum( _Tp );
    template < typename _Tp >
    inline constexpr bool is_union_v = __is_union( _Tp );
    template < typename _Tp >
    inline constexpr bool is_class_v = __is_class( _Tp );
    /// Alias template for common_type
    template < typename... _Tp >
    using common_type_t = typename common_type< _Tp... >::type;
    PUBLIC namespace detail {
        template < typename _Tp >
        using __cref = const remove_reference_t< _Tp > &;

        template < typename _Tp >
        concept __class_or_enum = is_class_v< _Tp > || is_union_v< _Tp > || is_enum_v< _Tp >;

        template < typename _Tp >
        constexpr bool __destructible_impl = false;
        template < typename _Tp >
            requires requires( _Tp &__t ) { { __t.~_Tp() } noexcept; }
        constexpr bool __destructible_impl< _Tp > = true;
        template < typename _Tp >
        constexpr bool __destructible = __destructible_impl< _Tp >;
        template < typename _Tp >
        constexpr bool __destructible< _Tp & > = true;
        template < typename _Tp >
        constexpr bool __destructible< _Tp && > = true;
        template < typename _Tp, Lib::Types::size_t _Nm >
        constexpr bool __destructible< _Tp[ _Nm ] > = __destructible< _Tp >;
    }     // namespace __detail
    template < typename _Tp, typename... _Args >
    inline constexpr bool is_constructible_v = __is_constructible( _Tp, _Args... );
    template < typename _Tp >
    inline constexpr bool is_default_constructible_v = __is_constructible( _Tp );
    template < typename _Tp, typename _Up >
    inline constexpr bool is_assignable_v = __is_assignable( _Tp, _Up );
    template < typename _Tp, typename... _Args >
    inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible( _Tp, _Args... );
    template < typename _Tp >
    inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible( _Tp );
    /// is_empty
    template < typename _Tp >
    struct is_empty : public integral_constant< bool, __is_empty( _Tp ) >
    {};

    /// is_polymorphic
    template < typename _Tp >
    struct is_polymorphic : public integral_constant< bool, __is_polymorphic( _Tp ) >
    {};

    // _Tp 即 上面的 _Head
    template < typename _Tp >
    struct __is_empty_non_tuple : is_empty< _Tp >
    {};

    //  __empty_not_final 用于判断没有final修饰的空类，是否能开启EBCO
    //    有 final修饰， 则直接为 false_type
    //    没有final修饰，则取决传入的类型 _Head 是否为空类
    template < typename _Tp >
    using __empty_not_final = typename conditional< __is_final( _Tp ), false_type, __is_empty_non_tuple< _Tp > >::type;
    template < bool, typename _Tp = void >
    struct enable_if
    {};

    // Partial specialization for true.
    template < typename _Tp >
    struct enable_if< true, _Tp >
    {
        typedef _Tp type;
    };

    // __enable_if_t (std::enable_if_t for C++11)
    template < bool _Cond, typename _Tp = void >
    using __enable_if_t = typename enable_if< _Cond, _Tp >::type;
    template < typename _Tp, typename _Up >
    inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable( _Tp, _Up );
    template < typename _Tp, typename... _Args >
    inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible( _Tp, _Args... );
    template < typename _Tp >
    inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible( _Tp );
    template < typename _Tp, typename _Up >
    inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable( _Tp, _Up );
    template < typename _Tp >
    inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor( _Tp );
}